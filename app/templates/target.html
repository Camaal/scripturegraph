<h6 class="collection-title">Cross-References</h6>
<div id="graph"></div>
<div class="color-scale">
  <div class="min">1</div>
  <div class="max">436</div>
</div>
<div class="verses">
  <div id="target_text" class="cross-references">
    {% for author in ftauthors %}
    <div class="person">
      <span class="material-icons">account_circle</span>
      <h4>{{author.author}}</h4>
    </div>
    {% for b in ftbooks if b.author == author.author %}
    {% for item in ftverses%}
    {% if b.book == item.book %}
    {% if b.chapter == item.chapter %}
    <span class="scripture">
                         <span style="color:rgba{{item.norm_degree | degreeColor}};">
                            {{item.text}}<sup>{{item.degree}}</sup>
                         </span>
                    </span>
    <h6 class="reference-name">{{b.book_name}} {{b.chapter}}: {{item.verse}}</h6>
    {% endif %}
    {% endif %}
    {% endfor %}
    {% endfor %}
    {% endfor %}
  </div>
</div>
<script>
    var obj = JSON.parse('{{ fdata|safe }}');
    var sf = new sigma({
        graph: obj,
        renderers: [{
            container: 'graph',
            type: 'canvas',
        }],
        settings: {
        labelThreshold: 5,
        defaultLabelSize: 12,
        defaultLabelColor: "#002147",
        defaultLabelBGColor: "#ddd",
        defaultHoverLabelBGColor: "#002147",
        defaultLabelHoverColor: "#fff",
        font: 'Source Serif Pro',
        singleHover: false,
        drawEdges: true,
        drawEdgeLabels: false,
        defaultEdgeType: "curvedArrow",
        webglEdgesBatchSize: 5,
        minNodeSize: 1,
        maxNodeSize: 7,
        minEdgeSize: 0.2,
        maxEdgeSize: 0.5,
        batchEdgesDrawing: true
        },
        function(sf) {
            // We first need to save the original colors of our
            // nodes and edges, like this:
            sf.graph.nodes().forEach(function (n) {
                n.originalColor = n.color;
            });
            sf.graph.edges().forEach(function (e) {
                e.originalColor = e.color;
            });

            // When a node is clicked, we check for each node
            // if it is a neighbor of the clicked one. If not,
            // we set its color as grey, and else, it takes its
            // original color.
            // We do the same for the edges, and we only keep
            // edges that have both extremities colored.
            sf.bind('clickNode', function (e) {
                var nodeId = e.data.node.id,
                    toKeep = sf.graph.neighbors(nodeId);
                toKeep[nodeId] = e.data.node;

                sf.graph.nodes().forEach(function (n) {
                    if (toKeep[n.id])
                        n.color = n.originalColor;
                    else
                        n.color = '#eee';
                });

                sf.graph.edges().forEach(function (e) {
                    if (toKeep[e.source] && toKeep[e.target])
                        e.color = e.originalColor;
                    else
                        e.color = '#eee';
                });

                // Since the data has been modified, we need to
                // call the refresh method to make the colors
                // update effective.
                sf.refresh();
            });

            // When the stage is clicked, we just color each
            // node and edge with its original color.
            sf.bind('clickStage', function (e) {
                sf.graph.nodes().forEach(function (n) {
                    n.color = n.originalColor;
                });

                sf.graph.edges().forEach(function (e) {
                    e.color = e.originalColor;
                });

                // Same as in the previous event:
                sf.refresh();
            });
        }
    });
    var dragListener = sigma.plugins.dragNodes(sf, sf.renderers[0]);

      dragListener.bind('startdrag', function(event) {
        console.log(event);
      });
      dragListener.bind('drag', function(event) {
        console.log(event);
      });
      dragListener.bind('drop', function(event) {
        console.log(event);
      });
      dragListener.bind('dragend', function(event) {
        console.log(event);
      });

      // Bind the events:
      sf.bind('overNode outNode clickNode doubleClickNode rightClickNode', function(e) {
        console.log(e.type, e.data.node.label, e.data.captor);
      });
      sf.bind('overEdge outEdge clickEdge doubleClickEdge rightClickEdge', function(e) {
        console.log(e.type, e.data.edge, e.data.captor);
      });
      sf.bind('clickStage', function(e) {
        console.log(e.type, e.data.captor);
      });
      sf.bind('doubleClickStage rightClickStage', function(e) {
        console.log(e.type, e.data.captor);
      });

      // sf.startForceAtlas2({worker: true, barnesHutOptimize: false});
</script>